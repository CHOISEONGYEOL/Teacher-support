<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ì§€ì¸µ ì‹œë®¬ë ˆì´í„° - ì§€êµ¬ê³¼í•™ êµìœ¡ìš©</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            padding: 20px;
            color: #eee;
        }

        h1 {
            text-align: center;
            margin-bottom: 20px;
            color: #fff;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .container {
            display: flex;
            gap: 20px;
            max-width: 1250px;
            margin: 0 auto;
            flex-wrap: wrap;
            justify-content: center;
        }

        .canvas-wrapper {
            background: #fff;
            border-radius: 12px;
            padding: 10px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        canvas {
            display: block;
            border: 2px solid #333;
            border-radius: 8px;
        }

        .controls {
            background: rgba(255,255,255,0.1);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 20px;
            width: 400px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            max-height: 85vh;
            overflow-y: auto;
        }

        .btn-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 15px;
        }

        button {
            padding: 10px 12px;
            font-size: 13px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: bold;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }

        button:active {
            transform: translateY(0);
        }

        .btn-deposit { background: linear-gradient(135deg, #4CAF50, #45a049); color: white; }
        .btn-erode { background: linear-gradient(135deg, #ff9800, #f57c00); color: white; }
        .btn-fault { background: linear-gradient(135deg, #2196F3, #1976D2); color: white; }
        .btn-intrusion { background: linear-gradient(135deg, #9c27b0, #7b1fa2); color: white; }
        .btn-fold { background: linear-gradient(135deg, #00bcd4, #0097a7); color: white; }
        .btn-reset { background: linear-gradient(135deg, #f44336, #d32f2f); color: white; }
        .btn-delete { background: linear-gradient(135deg, #ff5252, #d32f2f); color: white; padding: 5px 10px; font-size: 12px; }

        .divider {
            height: 2px;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            margin: 15px 0;
        }

        .section-title {
            color: #fff;
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 2px solid rgba(255,255,255,0.2);
            font-size: 14px;
        }

        .timeline {
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 15px;
            max-height: 180px;
            overflow-y: auto;
        }

        .timeline-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px;
            margin-bottom: 5px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 13px;
        }

        .timeline-item:hover { background: rgba(255,255,255,0.1); }
        .timeline-item.selected { background: rgba(255,255,255,0.2); box-shadow: 0 0 0 2px #fff; }

        .timeline-item .order {
            background: rgba(255,255,255,0.2);
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 12px;
            flex-shrink: 0;
        }

        .timeline-item.layer { border-left: 4px solid #4CAF50; }
        .timeline-item.fault { border-left: 4px solid #2196F3; }
        .timeline-item.intrusion { border-left: 4px solid #9c27b0; }
        .timeline-item.sill { border-left: 4px solid #e91e63; }
        .timeline-item.batholith { border-left: 4px solid #795548; }
        .timeline-item.erosion { border-left: 4px solid #ff9800; }
        .timeline-item.fold { border-left: 4px solid #00bcd4; }
        .timeline-item.tilt { border-left: 4px solid #607d8b; }

        .timeline-item .name { flex: 1; }
        .timeline-item .color-preview {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            border: 2px solid rgba(255,255,255,0.5);
            flex-shrink: 0;
        }

        .editor-panel {
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            padding: 15px;
            margin-top: 10px;
            display: none;
        }

        .editor-panel.active { display: block; }

        .editor-panel h4 {
            margin-bottom: 15px;
            color: #fff;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .slider-group {
            margin-bottom: 12px;
        }

        .slider-group label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 13px;
            color: #ccc;
        }

        .slider-group label span { color: #fff; font-weight: bold; }

        input[type="range"] {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: rgba(255,255,255,0.2);
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #fff;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }

        .fault-editor input[type="range"]::-webkit-slider-thumb { background: #2196F3; }
        .intrusion-editor input[type="range"]::-webkit-slider-thumb { background: #9c27b0; }
        .fold-editor input[type="range"]::-webkit-slider-thumb { background: #00bcd4; }
        .erosion-editor input[type="range"]::-webkit-slider-thumb { background: #ff9800; }

        .info-box {
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
            padding: 12px;
            font-size: 11px;
            color: #aaa;
            margin-top: 15px;
            line-height: 1.5;
        }

        .empty-msg {
            color: #888;
            text-align: center;
            padding: 20px;
            font-size: 13px;
        }

        .badge {
            font-size: 11px;
            padding: 2px 6px;
            border-radius: 4px;
            margin-left: 5px;
        }

        .badge.layer { background: #4CAF50; }
        .badge.fault { background: #2196F3; }
        .badge.intrusion { background: #9c27b0; }
        .badge.sill { background: #e91e63; }
        .badge.batholith { background: #795548; }
        .badge.fold { background: #00bcd4; }
        .badge.tilt { background: #607d8b; }
        .badge.erosion { background: #ff9800; }

        .fault-indicator {
            font-size: 11px;
            color: #aaa;
            margin-bottom: 10px;
            padding: 8px;
            background: rgba(0,0,0,0.2);
            border-radius: 6px;
        }

        .fault-indicator .highlight {
            color: #FFD700;
            font-weight: bold;
        }

        .sub-label {
            font-size: 11px;
            color: #888;
            margin-left: 5px;
        }

        .canvas-container {
            position: relative;
        }

        .fullscreen-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            background: rgba(0,0,0,0.6);
            color: white;
            border: none;
            border-radius: 6px;
            padding: 8px 12px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
            z-index: 10;
        }

        .fullscreen-btn:hover {
            background: rgba(0,0,0,0.8);
            transform: scale(1.05);
        }

        .canvas-wrapper:fullscreen {
            display: flex;
            align-items: center;
            justify-content: center;
            background: #1a1a2e;
            padding: 0;
        }

        .canvas-wrapper:fullscreen canvas {
            width: 100vw;
            height: 100vh;
            object-fit: contain;
            border: none;
        }

        .canvas-wrapper:-webkit-full-screen {
            display: flex;
            align-items: center;
            justify-content: center;
            background: #1a1a2e;
            padding: 0;
        }

        .canvas-wrapper:-webkit-full-screen canvas {
            width: 100vw;
            height: 100vh;
            object-fit: contain;
            border: none;
        }
    </style>
</head>
<body>
    <h1>ğŸ§± ì§€ì¸µ ì‹œë®¬ë ˆì´í„°</h1>

    <div class="container">
        <div class="canvas-wrapper" id="canvasWrapper">
            <div class="canvas-container">
                <canvas id="canvas" width="650" height="480"></canvas>
                <button class="fullscreen-btn" onclick="toggleFullscreen()">â›¶ ì „ì²´ í™”ë©´</button>
            </div>
        </div>

        <div class="controls">
            <div class="btn-group">
                <button class="btn-deposit" onclick="addLayer()">ğŸª¨ ì§€ì¸µ ì¶”ê°€</button>
                <button class="btn-erode" onclick="addErosion()">ğŸŒŠ ì¹¨ì‹(ë¶€ì •í•©)</button>
                <button class="btn-fold" onclick="addFold()">ğŸŒ€ ìŠµê³¡ ì¶”ê°€</button>
                <button class="btn-fold" onclick="addTilt()">â†—ï¸ ê²½ì‚¬(ê¸°ìš¸ê¸°)</button>
                <button class="btn-fault" onclick="addFault()">ğŸ“ ë‹¨ì¸µ ì¶”ê°€</button>
                <button class="btn-intrusion" onclick="addIntrusion()">ğŸ”¥ ì•”ë§¥ ê´€ì…</button>
                <button class="btn-intrusion" onclick="addSill()">ğŸ¥ ë³‘ë°˜ ê´€ì…</button>
                <button class="btn-intrusion" onclick="addBatholith()">ğŸ„ ì €ë°˜ ê´€ì…</button>
                <button class="btn-reset" onclick="resetAll()">ğŸ”„ ì´ˆê¸°í™”</button>
            </div>

            <div class="divider"></div>

            <div class="section-title">ğŸ“œ ì§€ì§ˆ ì´ë²¤íŠ¸ ìˆœì„œ (í´ë¦­í•˜ì—¬ í¸ì§‘)</div>
            <div class="timeline" id="timeline">
                <div class="empty-msg">ì´ë²¤íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤.<br>ìœ„ ë²„íŠ¼ìœ¼ë¡œ ì§€ì¸µ, ìŠµê³¡, ë‹¨ì¸µ, ê´€ì…ì„ ì¶”ê°€í•˜ì„¸ìš”.</div>
            </div>

            <!-- ì§€ì¸µ ì—ë””í„° -->
            <div class="editor-panel layer-editor" id="layerEditor">
                <h4>ğŸª¨ ì§€ì¸µ ì„¤ì • <span class="badge layer" id="layerBadge">ì§€ì¸µ 1</span></h4>
                <div class="slider-group">
                    <label>ë‘ê»˜: <span id="layerHeightVal">38</span>px</label>
                    <input type="range" id="layerHeight" min="10" max="500" value="38" oninput="updateLayer()">
                </div>
                <div style="margin: 10px 0; padding: 8px; background: rgba(255,255,255,0.1); border-radius: 4px;">
                    <span style="font-size: 11px; color: #aaa;">ìƒ‰ìƒ:</span>
                    <div id="layerColorPreview" style="display: inline-block; width: 60px; height: 20px; border-radius: 4px; vertical-align: middle; margin-left: 8px; border: 1px solid rgba(255,255,255,0.3);"></div>
                </div>
                <button class="btn-delete" onclick="deleteSelected()">ğŸ—‘ ì‚­ì œ</button>
            </div>

            <!-- ë‹¨ì¸µ ì—ë””í„° -->
            <div class="editor-panel fault-editor" id="faultEditor">
                <h4>ğŸ“ ë‹¨ì¸µ ì„¤ì • <span class="badge fault" id="faultBadge">ë‹¨ì¸µ 1</span></h4>

                <div class="fault-indicator" id="faultIndicator">
                    ë‹¨ì¸µë©´ ê¸°ìš¸ê¸°: <span class="highlight" id="faultDirection">ìˆ˜ì§</span><br>
                    ìƒë°˜: <span class="highlight" id="hangingWallSide">-</span> | í•˜ë°˜: <span class="highlight" id="footwallSide">-</span>
                </div>

                <div class="slider-group">
                    <label>ìœ„ì¹˜ (Xì¶•): <span id="faultPosVal">50</span>%</label>
                    <input type="range" id="faultPos" min="10" max="90" value="50" oninput="updateFault()">
                </div>
                <div class="slider-group">
                    <label>ë‹¨ì¸µë©´ ê°ë„: <span id="faultAngleVal">70</span>Â°</label>
                    <input type="range" id="faultAngle" min="45" max="135" value="70" oninput="updateFault()">
                </div>
                <div class="slider-group">
                    <label>ìƒë°˜ ì´ë™ (â†‘+/â†“-): <span id="faultHangingVal">0</span>px</label>
                    <input type="range" id="faultHanging" min="-80" max="80" value="0" oninput="updateFault()">
                </div>
                <div class="slider-group">
                    <label>í•˜ë°˜ ì´ë™ (â†‘+/â†“-): <span id="faultFootVal">0</span>px</label>
                    <input type="range" id="faultFoot" min="-80" max="80" value="0" oninput="updateFault()">
                </div>
                <button class="btn-delete" onclick="deleteSelected()">ğŸ—‘ ì‚­ì œ</button>
            </div>

            <!-- ì•”ë§¥ ê´€ì… ì—ë””í„° -->
            <div class="editor-panel intrusion-editor" id="intrusionEditor">
                <h4>ğŸ”¥ ì•”ë§¥ ì„¤ì • <span class="badge intrusion" id="intrusionBadge">ì•”ë§¥ 1</span></h4>
                <div class="slider-group">
                    <label>ìœ„ì¹˜ (Xì¶•): <span id="intrusionPosVal">50</span>%</label>
                    <input type="range" id="intrusionPos" min="5" max="95" value="50" oninput="updateIntrusion()">
                </div>
                <div class="slider-group">
                    <label>ê°ë„: <span id="intrusionAngleVal">90</span>Â°</label>
                    <input type="range" id="intrusionAngle" min="20" max="160" value="90" oninput="updateIntrusion()">
                </div>
                <div class="slider-group">
                    <label>ë‘ê»˜: <span id="intrusionWidthVal">25</span>px</label>
                    <input type="range" id="intrusionWidth" min="10" max="60" value="25" oninput="updateIntrusion()">
                </div>
                <div class="slider-group">
                    <label>ì ‘ì´‰ ë³€ì„±ëŒ€ ë‘ê»˜: <span id="intrusionMetaVal">12</span>px</label>
                    <input type="range" id="intrusionMeta" min="0" max="40" value="12" oninput="updateIntrusion()">
                </div>
                <button class="btn-delete" onclick="deleteSelected()">ğŸ—‘ ì‚­ì œ</button>
            </div>

            <!-- ë³‘ë°˜ ê´€ì… ì—ë””í„° -->
            <div class="editor-panel intrusion-editor" id="sillEditor">
                <h4>ğŸ¥ ë³‘ë°˜ ì„¤ì • <span class="badge intrusion" id="sillBadge">ë³‘ë°˜ 1</span></h4>
                <div class="slider-group">
                    <label>ìœ„ì¹˜ (Xì¶•): <span id="sillPosVal">50</span>%</label>
                    <input type="range" id="sillPos" min="10" max="90" value="50" oninput="updateSill()">
                </div>
                <div class="slider-group">
                    <label>ë„ˆë¹„: <span id="sillWidthVal">150</span>px</label>
                    <input type="range" id="sillWidth" min="50" max="800" value="150" oninput="updateSill()">
                </div>
                <div class="slider-group">
                    <label>ë†’ì´: <span id="sillHeightVal">40</span>px</label>
                    <input type="range" id="sillHeight" min="15" max="1000" value="40" oninput="updateSill()">
                </div>
                <div class="slider-group">
                    <label>ì ‘ì´‰ ë³€ì„±ëŒ€: <span id="sillMetaVal">10</span>px</label>
                    <input type="range" id="sillMeta" min="0" max="30" value="10" oninput="updateSill()">
                </div>
                <div class="slider-group">
                    <label>ê°ë„: <span id="sillAngleVal">0</span>Â°</label>
                    <input type="range" id="sillAngle" min="-30" max="30" value="0" oninput="updateSill()">
                </div>
                <button class="btn-delete" onclick="deleteSelected()">ğŸ—‘ ì‚­ì œ</button>
            </div>

            <!-- ì €ë°˜ ê´€ì… ì—ë””í„° -->
            <div class="editor-panel intrusion-editor" id="batholithEditor">
                <h4>ğŸ„ ì €ë°˜ ì„¤ì • <span class="badge batholith" id="batholithBadge">ì €ë°˜ 1</span></h4>
                <div class="slider-group">
                    <label>ìœ„ì¹˜ (Xì¶•): <span id="batholithPosVal">50</span>%</label>
                    <input type="range" id="batholithPos" min="10" max="90" value="50" oninput="updateBatholith()">
                </div>
                <div class="slider-group">
                    <label>ì¤„ê¸° ë„ˆë¹„: <span id="batholithStemWidthVal">40</span>px</label>
                    <input type="range" id="batholithStemWidth" min="20" max="100" value="40" oninput="updateBatholith()">
                </div>
                <div class="slider-group">
                    <label>ë¨¸ë¦¬ ë„ˆë¹„: <span id="batholithHeadWidthVal">200</span>px</label>
                    <input type="range" id="batholithHeadWidth" min="80" max="2000" value="200" oninput="updateBatholith()">
                </div>
                <div class="slider-group">
                    <label>ë¨¸ë¦¬ ë†’ì´: <span id="batholithHeadHeightVal">60</span>px</label>
                    <input type="range" id="batholithHeadHeight" min="20" max="150" value="60" oninput="updateBatholith()">
                </div>
                <div class="slider-group">
                    <label>ë¨¸ë¦¬ Yìœ„ì¹˜: <span id="batholithHeadPosYVal">100</span>px</label>
                    <input type="range" id="batholithHeadPosY" min="20" max="500" value="100" oninput="updateBatholith()">
                </div>
                <div class="slider-group">
                    <label>ì ‘ì´‰ ë³€ì„±ëŒ€: <span id="batholithMetaVal">15</span>px</label>
                    <input type="range" id="batholithMeta" min="0" max="40" value="15" oninput="updateBatholith()">
                </div>
                <div class="slider-group">
                    <label>ì¤„ê¸° ê¸°ìš¸ê¸°: <span id="batholithStemAngleVal">0</span>Â°</label>
                    <input type="range" id="batholithStemAngle" min="-45" max="45" value="0" oninput="updateBatholith()">
                </div>
                <button class="btn-delete" onclick="deleteSelected()">ğŸ—‘ ì‚­ì œ</button>
            </div>

            <!-- ìŠµê³¡ ì—ë””í„° -->
            <div class="editor-panel fold-editor" id="foldEditor">
                <h4>ğŸŒ€ ìŠµê³¡ ì„¤ì • <span class="badge fold" id="foldBadge">ìŠµê³¡ 1</span></h4>
                <div class="slider-group">
                    <label>ì¤‘ì‹¬ ìœ„ì¹˜ (Xì¶•): <span id="foldPosVal">50</span>%</label>
                    <input type="range" id="foldPos" min="10" max="90" value="50" oninput="updateFold()">
                </div>
                <div class="slider-group">
                    <label>ì§„í­ (íœ˜ì–´ì§ ê°•ë„): <span id="foldAmplitudeVal">40</span>px</label>
                    <input type="range" id="foldAmplitude" min="10" max="100" value="40" oninput="updateFold()">
                </div>
                <div class="slider-group">
                    <label>íŒŒì¥ (í­): <span id="foldWavelengthVal">200</span>px</label>
                    <input type="range" id="foldWavelength" min="80" max="2000" value="200" oninput="updateFold()">
                </div>
                <button class="btn-delete" onclick="deleteSelected()">ğŸ—‘ ì‚­ì œ</button>
            </div>

            <!-- ê²½ì‚¬ ì—ë””í„° -->
            <div class="editor-panel fold-editor" id="tiltEditor">
                <h4>â†—ï¸ ê²½ì‚¬(ê¸°ìš¸ê¸°) ì„¤ì • <span class="badge tilt" id="tiltBadge">ê²½ì‚¬ 1</span></h4>
                <div class="slider-group">
                    <label>ê¸°ìš¸ê¸° ê°ë„: <span id="tiltAngleVal">0</span>Â°</label>
                    <input type="range" id="tiltAngle" min="-30" max="30" value="0" oninput="updateTilt()">
                </div>
                <div style="font-size: 11px; color: #aaa; margin: 8px 0;">
                    ìŒìˆ˜(-): ì™¼ìª½ ê¸°ìš¸ê¸° â†™<br>
                    ì–‘ìˆ˜(+): ì˜¤ë¥¸ìª½ ê¸°ìš¸ê¸° â†˜
                </div>
                <button class="btn-delete" onclick="deleteSelected()">ğŸ—‘ ì‚­ì œ</button>
            </div>

            <!-- ì¹¨ì‹ ì—ë””í„° -->
            <div class="editor-panel erosion-editor" id="erosionEditor">
                <h4>ğŸŒŠ ì¹¨ì‹(ë¶€ì •í•©) ì„¤ì • <span class="badge erosion" id="erosionBadge">ì¹¨ì‹ 1</span></h4>
                <div class="slider-group">
                    <label>ì¹¨ì‹ ê¹Šì´: <span id="erosionAmountVal">30</span>px</label>
                    <input type="range" id="erosionAmount" min="-50" max="80" value="30" oninput="updateErosion()">
                </div>
                <div class="slider-group">
                    <label>íŒŒí˜• ì§„í­: <span id="erosionWaveVal">12</span>px</label>
                    <input type="range" id="erosionWave" min="3" max="30" value="12" oninput="updateErosion()">
                </div>
                <div class="slider-group">
                    <label>íŒŒí˜• ì£¼ê¸°: <span id="erosionFreqVal">80</span>px</label>
                    <input type="range" id="erosionFreq" min="30" max="150" value="80" oninput="updateErosion()">
                </div>
                <button class="btn-delete" onclick="deleteSelected()">ğŸ—‘ ì‚­ì œ</button>
            </div>

            <div class="info-box">
                ğŸ’¡ <strong>ë‹¨ì¸µ ìš©ì–´:</strong><br>
                â€¢ ìƒë°˜(Hanging Wall): ë‹¨ì¸µë©´ ìœ„ìª½ ë¸”ë¡<br>
                â€¢ í•˜ë°˜(Footwall): ë‹¨ì¸µë©´ ì•„ë˜ìª½ ë¸”ë¡<br>
                â€¢ ì •ë‹¨ì¸µ: ìƒë°˜â†“ / ì—­ë‹¨ì¸µ: ìƒë°˜â†‘
            </div>
        </div>
    </div>

    <script>
        // ========================================
        // ì „ì—­ ë³€ìˆ˜ ë° ìƒíƒœ ê´€ë¦¬
        // ========================================
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;
        const LAYER_HEIGHT = 38;

        // ========================================
        // ê°€ìƒ ìº”ë²„ìŠ¤ ì‹œìŠ¤í…œ (ë¬´í•œ í™•ì¥ ì›ì¹™)
        // ëª¨ë“  ì§€ì¸µ/ë³€í˜•ì€ ë³´ì´ëŠ” í™”ë©´ë³´ë‹¤ í›¨ì”¬ ë„“ê²Œ ê·¸ë ¤ì„œ
        // íšŒì „/ê¸°ìš¸ê¸° ì ìš© ì‹œ ì˜ë¦¼ í˜„ìƒì„ ë°©ì§€í•¨
        // ========================================
        const VIRTUAL_SCALE = 3;  // ê°€ìƒ ìº”ë²„ìŠ¤ ë°°ìœ¨
        const VIRTUAL_WIDTH = WIDTH * VIRTUAL_SCALE;
        const VIRTUAL_HEIGHT = HEIGHT * VIRTUAL_SCALE;
        const OFFSET_X = WIDTH;   // ê°€ì‹œ ì˜ì—­ì˜ ì‹œì‘ X (ê°€ìƒ ìº”ë²„ìŠ¤ ë‚´)
        const OFFSET_Y = HEIGHT;  // ê°€ì‹œ ì˜ì—­ì˜ ì‹œì‘ Y (ê°€ìƒ ìº”ë²„ìŠ¤ ë‚´)

        let events = [];
        let selectedIndex = -1;

        let layerCount = 0;
        let faultCount = 0;
        let intrusionCount = 0;
        let sillCount = 0;
        let batholithCount = 0;
        let erosionCount = 0;
        let foldCount = 0;
        let tiltCount = 0;

        // ìƒ‰ìƒ ì¸ë±ìŠ¤ (ìˆœí™˜)
        let colorIndex = 0;

        // ========================================
        // ëšœë ·í•œ ì§€ì¸µ ìƒ‰ìƒ (ì±„ë„ ë†’ìŒ, êµ¬ë¶„ ëª…í™•)
        // ========================================
        const VIVID_COLORS = [
            '#E63946',  // ë¹¨ê°•
            '#2A9D8F',  // ì²­ë¡
            '#264653',  // ë‚¨ìƒ‰
            '#8338EC',  // ë³´ë¼
            '#3A86FF',  // íŒŒë‘
            '#06D6A0',  // ë¯¼íŠ¸
            '#EF476F',  // ë¶„í™
            '#073B4C',  // ì§„í•œ ë‚¨ìƒ‰
            '#118AB2',  // ì²­ìƒ‰
            '#06AED5',  // í•˜ëŠ˜ìƒ‰
            '#9B5DE5',  // ì—°ë³´ë¼
            '#F15BB5',  // í•«í•‘í¬
        ];

        function getNextColor() {
            const color = VIVID_COLORS[colorIndex % VIVID_COLORS.length];
            colorIndex++;
            return color;
        }

        // ========================================
        // ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜
        // ========================================

        function generateErosionSurface(baseY, erosion) {
            // ë¬´í•œ í™•ì¥ ì›ì¹™: ê°€ìƒ ìº”ë²„ìŠ¤ ì „ì²´ ë„ˆë¹„ë¡œ ìƒì„±
            const points = [];
            const segments = 120;
            const waveAmplitude = erosion.waveAmplitude || 12;
            const waveFrequency = erosion.waveFrequency || 80;
            const phase = erosion.seed || 0;

            for (let i = 0; i <= segments; i++) {
                const x = (i / segments) * VIRTUAL_WIDTH;
                const wave = Math.sin((x / waveFrequency) * Math.PI * 2 + phase) * waveAmplitude;
                points.push({ x, y: baseY + wave });
            }
            return points;
        }

        function getErosionYAtX(erosionPoints, x) {
            if (!erosionPoints || erosionPoints.length === 0) return HEIGHT;

            for (let i = 0; i < erosionPoints.length - 1; i++) {
                if (x >= erosionPoints[i].x && x <= erosionPoints[i + 1].x) {
                    const t = (x - erosionPoints[i].x) / (erosionPoints[i + 1].x - erosionPoints[i].x);
                    return erosionPoints[i].y + t * (erosionPoints[i + 1].y - erosionPoints[i].y);
                }
            }
            return erosionPoints[erosionPoints.length - 1].y;
        }

        // ========================================
        // ì´ë²¤íŠ¸ ì¶”ê°€ í•¨ìˆ˜ë“¤
        // ========================================

        function addLayer() {
            layerCount++;
            const newLayer = {
                type: 'layer',
                name: `ì§€ì¸µ ${layerCount}`,
                color: getNextColor(),
                height: LAYER_HEIGHT
            };
            events.push(newLayer);
            selectedIndex = events.length - 1;
            updateTimeline();
            showEditor('layer');
            loadLayerToEditor(newLayer);
            render();
        }

        function addErosion() {
            const hasLayer = events.some(e => e.type === 'layer');
            if (!hasLayer) {
                alert('ì¹¨ì‹í•  ì§€ì¸µì´ ì—†ìŠµë‹ˆë‹¤!');
                return;
            }
            erosionCount++;
            const newErosion = {
                type: 'erosion',
                name: `ì¹¨ì‹ ${erosionCount}`,
                amount: 30,
                waveAmplitude: 12,
                waveFrequency: 80,
                seed: Math.random() * Math.PI * 2
            };
            events.push(newErosion);
            selectedIndex = events.length - 1;
            updateTimeline();
            showEditor('erosion');
            loadErosionToEditor(newErosion);
            render();
        }

        function addFault() {
            faultCount++;
            const newFault = {
                type: 'fault',
                name: `ë‹¨ì¸µ ${faultCount}`,
                position: 50,
                angle: 70,  // ê¸°ë³¸ê°’: ì™¼ìª½ì´ ìƒë°˜
                hangingWallOffset: 0,  // ìƒë°˜ ì´ë™
                footwallOffset: 0       // í•˜ë°˜ ì´ë™
            };
            events.push(newFault);
            selectedIndex = events.length - 1;
            updateTimeline();
            showEditor('fault');
            loadFaultToEditor(newFault);
            render();
        }

        function addIntrusion() {
            intrusionCount++;
            const newIntrusion = {
                type: 'intrusion',
                name: `ì•”ë§¥ ${intrusionCount}`,
                position: 50,
                angle: 90,
                width: 25,
                metaThickness: 12
            };
            events.push(newIntrusion);
            selectedIndex = events.length - 1;
            updateTimeline();
            showEditor('intrusion');
            loadIntrusionToEditor(newIntrusion);
            render();
        }

        function addSill() {
            sillCount++;
            const newSill = {
                type: 'sill',
                name: `ë³‘ë°˜ ${sillCount}`,
                position: 50,
                depth: 50,  // 50% = ë§¨ ë°‘ë°”ë‹¥
                angle: 0,   // ê¸°ìš¸ê¸° (-30 ~ +30ë„)
                width: 150,
                height: 40,
                metaThickness: 10
            };
            events.push(newSill);
            selectedIndex = events.length - 1;
            updateTimeline();
            showEditor('sill');
            loadSillToEditor(newSill);
            render();
        }

        function addBatholith() {
            batholithCount++;
            const newBatholith = {
                type: 'batholith',
                name: `ì €ë°˜ ${batholithCount}`,
                position: 50,
                stemWidth: 40,      // ì¤„ê¸° ë„ˆë¹„
                headWidth: 200,     // ë¨¸ë¦¬(í¼ì§„ ë¶€ë¶„) ë„ˆë¹„
                headHeight: 60,     // ë¨¸ë¦¬ ë†’ì´
                headPosY: 240,      // ë¨¸ë¦¬ Yì¶• ìœ„ì¹˜ (í™”ë©´ ì¤‘ê°„)
                metaThickness: 15,
                stemAngle: 0        // ì¤„ê¸° ê¸°ìš¸ê¸° (-45 ~ +45ë„)
            };
            events.push(newBatholith);
            selectedIndex = events.length - 1;
            updateTimeline();
            showEditor('batholith');
            loadBatholithToEditor(newBatholith);
            render();
        }

        function addFold() {
            foldCount++;
            const newFold = {
                type: 'fold',
                name: `ìŠµê³¡ ${foldCount}`,
                position: 50,
                amplitude: 40,
                wavelength: 200
            };
            events.push(newFold);
            selectedIndex = events.length - 1;
            updateTimeline();
            showEditor('fold');
            loadFoldToEditor(newFold);
            render();
        }

        function addTilt() {
            tiltCount++;
            const newTilt = {
                type: 'tilt',
                name: `ê²½ì‚¬ ${tiltCount}`,
                angle: 0  // ìŒìˆ˜: ì™¼ìª½ ê¸°ìš¸ê¸°, ì–‘ìˆ˜: ì˜¤ë¥¸ìª½ ê¸°ìš¸ê¸°
            };
            events.push(newTilt);
            selectedIndex = events.length - 1;
            updateTimeline();
            showEditor('tilt');
            loadTiltToEditor(newTilt);
            render();
        }

        // ========================================
        // íƒ€ì„ë¼ì¸ UI
        // ========================================

        function updateTimeline() {
            const timeline = document.getElementById('timeline');

            if (events.length === 0) {
                timeline.innerHTML = '<div class="empty-msg">ì´ë²¤íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤.<br>ìœ„ ë²„íŠ¼ìœ¼ë¡œ ì§€ì¸µ, ìŠµê³¡, ë‹¨ì¸µ, ê´€ì…ì„ ì¶”ê°€í•˜ì„¸ìš”.</div>';
                hideEditors();
                return;
            }

            const iconMap = {
                layer: 'ğŸª¨', fault: 'ğŸ“', intrusion: 'ğŸ”¥', sill: 'ğŸ¥', batholith: 'ğŸ„', erosion: 'ğŸŒŠ', fold: 'ğŸŒ€', tilt: 'â†—ï¸'
            };

            let html = '';
            events.forEach((event, index) => {
                const isSelected = index === selectedIndex;
                html += `
                    <div class="timeline-item ${event.type} ${isSelected ? 'selected' : ''}"
                         onclick="selectEvent(${index})">
                        <div class="order">${index + 1}</div>
                        <span class="name">${iconMap[event.type]} ${event.name}</span>
                        ${event.color ? `<div class="color-preview" style="background:${event.color}"></div>` : ''}
                    </div>
                `;
            });

            timeline.innerHTML = html;
        }

        function selectEvent(index) {
            selectedIndex = index;
            updateTimeline();

            const event = events[index];
            if (event.type === 'layer') {
                showEditor('layer');
                loadLayerToEditor(event);
            } else if (event.type === 'fault') {
                showEditor('fault');
                loadFaultToEditor(event);
            } else if (event.type === 'intrusion') {
                showEditor('intrusion');
                loadIntrusionToEditor(event);
            } else if (event.type === 'sill') {
                showEditor('sill');
                loadSillToEditor(event);
            } else if (event.type === 'batholith') {
                showEditor('batholith');
                loadBatholithToEditor(event);
            } else if (event.type === 'fold') {
                showEditor('fold');
                loadFoldToEditor(event);
            } else if (event.type === 'tilt') {
                showEditor('tilt');
                loadTiltToEditor(event);
            } else if (event.type === 'erosion') {
                showEditor('erosion');
                loadErosionToEditor(event);
            } else {
                hideEditors();
            }

            render();
        }

        function showEditor(type) {
            document.getElementById('layerEditor').classList.remove('active');
            document.getElementById('faultEditor').classList.remove('active');
            document.getElementById('intrusionEditor').classList.remove('active');
            document.getElementById('sillEditor').classList.remove('active');
            document.getElementById('batholithEditor').classList.remove('active');
            document.getElementById('foldEditor').classList.remove('active');
            document.getElementById('tiltEditor').classList.remove('active');
            document.getElementById('erosionEditor').classList.remove('active');

            if (type === 'layer') document.getElementById('layerEditor').classList.add('active');
            else if (type === 'fault') document.getElementById('faultEditor').classList.add('active');
            else if (type === 'intrusion') document.getElementById('intrusionEditor').classList.add('active');
            else if (type === 'sill') document.getElementById('sillEditor').classList.add('active');
            else if (type === 'batholith') document.getElementById('batholithEditor').classList.add('active');
            else if (type === 'fold') document.getElementById('foldEditor').classList.add('active');
            else if (type === 'tilt') document.getElementById('tiltEditor').classList.add('active');
            else if (type === 'erosion') document.getElementById('erosionEditor').classList.add('active');
        }

        function hideEditors() {
            document.getElementById('layerEditor').classList.remove('active');
            document.getElementById('faultEditor').classList.remove('active');
            document.getElementById('intrusionEditor').classList.remove('active');
            document.getElementById('sillEditor').classList.remove('active');
            document.getElementById('batholithEditor').classList.remove('active');
            document.getElementById('foldEditor').classList.remove('active');
            document.getElementById('tiltEditor').classList.remove('active');
            document.getElementById('erosionEditor').classList.remove('active');
        }

        // ========================================
        // ì—ë””í„° ë™ê¸°í™”
        // ========================================

        function loadLayerToEditor(layer) {
            document.getElementById('layerHeight').value = layer.height;
            document.getElementById('layerHeightVal').textContent = layer.height;
            document.getElementById('layerBadge').textContent = layer.name;
            document.getElementById('layerColorPreview').style.background = layer.color;
        }

        function loadFaultToEditor(fault) {
            document.getElementById('faultPos').value = fault.position;
            document.getElementById('faultAngle').value = fault.angle;
            document.getElementById('faultHanging').value = fault.hangingWallOffset || 0;
            document.getElementById('faultFoot').value = fault.footwallOffset || 0;

            document.getElementById('faultPosVal').textContent = fault.position;
            document.getElementById('faultAngleVal').textContent = fault.angle;
            document.getElementById('faultHangingVal').textContent = fault.hangingWallOffset || 0;
            document.getElementById('faultFootVal').textContent = fault.footwallOffset || 0;
            document.getElementById('faultBadge').textContent = fault.name;

            updateFaultIndicator(fault.angle);
        }

        function updateFaultIndicator(angle) {
            const directionEl = document.getElementById('faultDirection');
            const hangingSideEl = document.getElementById('hangingWallSide');
            const footwallSideEl = document.getElementById('footwallSide');

            if (angle < 90) {
                // ë‹¨ì¸µë©´ì´ ì˜¤ë¥¸ìª½ ìœ„ â†’ ì™¼ìª½ ì•„ë˜ë¡œ ê¸°ìš¸ì–´ì§ (/)
                directionEl.textContent = `${angle}Â° (/ ê¸°ìš¸ê¸°)`;
                hangingSideEl.textContent = 'ì™¼ìª½';
                footwallSideEl.textContent = 'ì˜¤ë¥¸ìª½';
            } else if (angle > 90) {
                // ë‹¨ì¸µë©´ì´ ì™¼ìª½ ìœ„ â†’ ì˜¤ë¥¸ìª½ ì•„ë˜ë¡œ ê¸°ìš¸ì–´ì§ (\)
                directionEl.textContent = `${angle}Â° (\\ ê¸°ìš¸ê¸°)`;
                hangingSideEl.textContent = 'ì˜¤ë¥¸ìª½';
                footwallSideEl.textContent = 'ì™¼ìª½';
            } else {
                directionEl.textContent = '90Â° (ìˆ˜ì§)';
                hangingSideEl.textContent = '-';
                footwallSideEl.textContent = '-';
            }
        }

        function loadIntrusionToEditor(intrusion) {
            document.getElementById('intrusionPos').value = intrusion.position;
            document.getElementById('intrusionAngle').value = intrusion.angle;
            document.getElementById('intrusionWidth').value = intrusion.width;
            document.getElementById('intrusionMeta').value = intrusion.metaThickness;
            document.getElementById('intrusionPosVal').textContent = intrusion.position;
            document.getElementById('intrusionAngleVal').textContent = intrusion.angle;
            document.getElementById('intrusionWidthVal').textContent = intrusion.width;
            document.getElementById('intrusionMetaVal').textContent = intrusion.metaThickness;
            document.getElementById('intrusionBadge').textContent = intrusion.name;
        }

        function loadSillToEditor(sill) {
            document.getElementById('sillPos').value = sill.position;
            document.getElementById('sillAngle').value = sill.angle || 0;
            document.getElementById('sillWidth').value = sill.width;
            document.getElementById('sillHeight').value = sill.height;
            document.getElementById('sillMeta').value = sill.metaThickness;
            document.getElementById('sillPosVal').textContent = sill.position;
            document.getElementById('sillAngleVal').textContent = sill.angle || 0;
            document.getElementById('sillWidthVal').textContent = sill.width;
            document.getElementById('sillHeightVal').textContent = sill.height;
            document.getElementById('sillMetaVal').textContent = sill.metaThickness;
            document.getElementById('sillBadge').textContent = sill.name;
        }

        function loadBatholithToEditor(batholith) {
            document.getElementById('batholithPos').value = batholith.position;
            document.getElementById('batholithStemWidth').value = batholith.stemWidth;
            document.getElementById('batholithHeadWidth').value = batholith.headWidth;
            document.getElementById('batholithHeadHeight').value = batholith.headHeight;
            document.getElementById('batholithHeadPosY').value = batholith.headPosY || 100;
            document.getElementById('batholithMeta').value = batholith.metaThickness;
            document.getElementById('batholithStemAngle').value = batholith.stemAngle || 0;
            document.getElementById('batholithPosVal').textContent = batholith.position;
            document.getElementById('batholithStemWidthVal').textContent = batholith.stemWidth;
            document.getElementById('batholithHeadWidthVal').textContent = batholith.headWidth;
            document.getElementById('batholithHeadHeightVal').textContent = batholith.headHeight;
            document.getElementById('batholithHeadPosYVal').textContent = batholith.headPosY || 100;
            document.getElementById('batholithMetaVal').textContent = batholith.metaThickness;
            document.getElementById('batholithStemAngleVal').textContent = batholith.stemAngle || 0;
            document.getElementById('batholithBadge').textContent = batholith.name;
        }

        function loadFoldToEditor(fold) {
            document.getElementById('foldPos').value = fold.position;
            document.getElementById('foldAmplitude').value = fold.amplitude;
            document.getElementById('foldWavelength').value = fold.wavelength;
            document.getElementById('foldPosVal').textContent = fold.position;
            document.getElementById('foldAmplitudeVal').textContent = fold.amplitude;
            document.getElementById('foldWavelengthVal').textContent = fold.wavelength;
            document.getElementById('foldBadge').textContent = fold.name;
        }

        function loadTiltToEditor(tilt) {
            document.getElementById('tiltAngle').value = tilt.angle;
            document.getElementById('tiltAngleVal').textContent = tilt.angle;
            document.getElementById('tiltBadge').textContent = tilt.name;
        }

        function loadErosionToEditor(erosion) {
            document.getElementById('erosionAmount').value = erosion.amount;
            document.getElementById('erosionWave').value = erosion.waveAmplitude;
            document.getElementById('erosionFreq').value = erosion.waveFrequency;
            document.getElementById('erosionAmountVal').textContent = erosion.amount;
            document.getElementById('erosionWaveVal').textContent = erosion.waveAmplitude;
            document.getElementById('erosionFreqVal').textContent = erosion.waveFrequency;
            document.getElementById('erosionBadge').textContent = erosion.name;
        }

        function updateLayer() {
            if (selectedIndex < 0 || events[selectedIndex]?.type !== 'layer') return;
            const layer = events[selectedIndex];
            layer.height = parseInt(document.getElementById('layerHeight').value);
            document.getElementById('layerHeightVal').textContent = layer.height;
            render();
        }

        function updateFault() {
            if (selectedIndex < 0 || events[selectedIndex]?.type !== 'fault') return;
            const fault = events[selectedIndex];
            fault.position = parseInt(document.getElementById('faultPos').value);
            fault.angle = parseInt(document.getElementById('faultAngle').value);
            fault.hangingWallOffset = parseInt(document.getElementById('faultHanging').value);
            fault.footwallOffset = parseInt(document.getElementById('faultFoot').value);

            document.getElementById('faultPosVal').textContent = fault.position;
            document.getElementById('faultAngleVal').textContent = fault.angle;
            document.getElementById('faultHangingVal').textContent = fault.hangingWallOffset;
            document.getElementById('faultFootVal').textContent = fault.footwallOffset;

            updateFaultIndicator(fault.angle);
            render();
        }

        function updateIntrusion() {
            if (selectedIndex < 0 || events[selectedIndex]?.type !== 'intrusion') return;
            const intrusion = events[selectedIndex];
            intrusion.position = parseInt(document.getElementById('intrusionPos').value);
            intrusion.angle = parseInt(document.getElementById('intrusionAngle').value);
            intrusion.width = parseInt(document.getElementById('intrusionWidth').value);
            intrusion.metaThickness = parseInt(document.getElementById('intrusionMeta').value);
            document.getElementById('intrusionPosVal').textContent = intrusion.position;
            document.getElementById('intrusionAngleVal').textContent = intrusion.angle;
            document.getElementById('intrusionWidthVal').textContent = intrusion.width;
            document.getElementById('intrusionMetaVal').textContent = intrusion.metaThickness;
            render();
        }

        function updateSill() {
            if (selectedIndex < 0 || events[selectedIndex]?.type !== 'sill') return;
            const sill = events[selectedIndex];
            sill.position = parseInt(document.getElementById('sillPos').value);
            sill.angle = parseInt(document.getElementById('sillAngle').value);
            sill.width = parseInt(document.getElementById('sillWidth').value);
            sill.height = parseInt(document.getElementById('sillHeight').value);
            sill.metaThickness = parseInt(document.getElementById('sillMeta').value);
            document.getElementById('sillPosVal').textContent = sill.position;
            document.getElementById('sillAngleVal').textContent = sill.angle;
            document.getElementById('sillWidthVal').textContent = sill.width;
            document.getElementById('sillHeightVal').textContent = sill.height;
            document.getElementById('sillMetaVal').textContent = sill.metaThickness;
            render();
        }

        function updateBatholith() {
            if (selectedIndex < 0 || events[selectedIndex]?.type !== 'batholith') return;
            const batholith = events[selectedIndex];
            batholith.position = parseInt(document.getElementById('batholithPos').value);
            batholith.stemWidth = parseInt(document.getElementById('batholithStemWidth').value);
            batholith.headWidth = parseInt(document.getElementById('batholithHeadWidth').value);
            batholith.headHeight = parseInt(document.getElementById('batholithHeadHeight').value);
            batholith.headPosY = parseInt(document.getElementById('batholithHeadPosY').value);
            batholith.metaThickness = parseInt(document.getElementById('batholithMeta').value);
            batholith.stemAngle = parseInt(document.getElementById('batholithStemAngle').value);
            document.getElementById('batholithPosVal').textContent = batholith.position;
            document.getElementById('batholithStemWidthVal').textContent = batholith.stemWidth;
            document.getElementById('batholithHeadWidthVal').textContent = batholith.headWidth;
            document.getElementById('batholithHeadHeightVal').textContent = batholith.headHeight;
            document.getElementById('batholithHeadPosYVal').textContent = batholith.headPosY;
            document.getElementById('batholithMetaVal').textContent = batholith.metaThickness;
            document.getElementById('batholithStemAngleVal').textContent = batholith.stemAngle;
            render();
        }

        function updateFold() {
            if (selectedIndex < 0 || events[selectedIndex]?.type !== 'fold') return;
            const fold = events[selectedIndex];
            fold.position = parseInt(document.getElementById('foldPos').value);
            fold.amplitude = parseInt(document.getElementById('foldAmplitude').value);
            fold.wavelength = parseInt(document.getElementById('foldWavelength').value);
            document.getElementById('foldPosVal').textContent = fold.position;
            document.getElementById('foldAmplitudeVal').textContent = fold.amplitude;
            document.getElementById('foldWavelengthVal').textContent = fold.wavelength;
            render();
        }

        function updateTilt() {
            if (selectedIndex < 0 || events[selectedIndex]?.type !== 'tilt') return;
            const tilt = events[selectedIndex];
            tilt.angle = parseInt(document.getElementById('tiltAngle').value);
            document.getElementById('tiltAngleVal').textContent = tilt.angle;
            render();
        }

        function updateErosion() {
            if (selectedIndex < 0 || events[selectedIndex]?.type !== 'erosion') return;
            const erosion = events[selectedIndex];
            erosion.amount = parseInt(document.getElementById('erosionAmount').value);
            erosion.waveAmplitude = parseInt(document.getElementById('erosionWave').value);
            erosion.waveFrequency = parseInt(document.getElementById('erosionFreq').value);
            document.getElementById('erosionAmountVal').textContent = erosion.amount;
            document.getElementById('erosionWaveVal').textContent = erosion.waveAmplitude;
            document.getElementById('erosionFreqVal').textContent = erosion.waveFrequency;
            render();
        }

        function deleteSelected() {
            if (selectedIndex < 0) return;
            events.splice(selectedIndex, 1);
            selectedIndex = -1;
            hideEditors();
            updateTimeline();
            render();
        }

        function resetAll() {
            events = [];
            selectedIndex = -1;
            layerCount = faultCount = intrusionCount = sillCount = batholithCount = erosionCount = foldCount = tiltCount = 0;
            colorIndex = 0;
            hideEditors();
            updateTimeline();
            render();
        }

        // ========================================
        // í•µì‹¬ ë Œë”ë§ ì‹œìŠ¤í…œ
        // ========================================

        function render() {
            ctx.clearRect(0, 0, WIDTH, HEIGHT);
            drawBackground(ctx, WIDTH, HEIGHT);

            if (events.length === 0) {
                drawEmptyMessage();
                return;
            }

            // ê°€ìƒ ìº”ë²„ìŠ¤ ìƒì„± (ë³´ì´ëŠ” í™”ë©´ì˜ 3ë°° í¬ê¸°)
            let workCanvas = document.createElement('canvas');
            workCanvas.width = VIRTUAL_WIDTH;
            workCanvas.height = VIRTUAL_HEIGHT;
            let workCtx = workCanvas.getContext('2d');

            // ê°€ìƒ ìº”ë²„ìŠ¤ì— ë°°ê²½ ê·¸ë¦¬ê¸°
            drawBackground(workCtx, VIRTUAL_WIDTH, VIRTUAL_HEIGHT);

            // ë¬´í•œ í™•ì¥ ì›ì¹™: ì•„ë˜ìª½ ì˜ì—­ë„ ì²« ë²ˆì§¸ ì§€ì¸µ ìƒ‰ìƒìœ¼ë¡œ ì±„ìš°ê¸°
            // (ê¸°ìš¸ê¸° ì ìš© ì‹œ ì•„ë˜ìª½ ë¹ˆ ê³µê°„ ë°©ì§€)
            const firstLayer = events.find(e => e.type === 'layer');
            if (firstLayer) {
                workCtx.fillStyle = firstLayer.color;
                workCtx.fillRect(0, OFFSET_Y + HEIGHT, VIRTUAL_WIDTH, VIRTUAL_HEIGHT - (OFFSET_Y + HEIGHT));
            }

            // surfaceYëŠ” ê°€ìƒ ìº”ë²„ìŠ¤ ê¸°ì¤€ (ê°€ì‹œ ì˜ì—­ í•˜ë‹¨ = OFFSET_Y + HEIGHT)
            let surfaceY = OFFSET_Y + HEIGHT;
            let foldFunctions = [];
            let activeErosionPoints = null;

            // ============================================
            // í•µì‹¬ ì›ì¹™: ëª¨ë“  ê²ƒì„ ìˆœì„œëŒ€ë¡œ ìº”ë²„ìŠ¤ì— ê·¸ë¦°ë‹¤
            // ë‚˜ì¤‘ ì´ë²¤íŠ¸ëŠ” ì´ì „ ê²ƒì„ "êµ³ì–´ì§„ ì‚¬ì§„ì²˜ëŸ¼" ë®ì–´ì“´ë‹¤
            // ============================================

            for (let i = 0; i < events.length; i++) {
                const event = events[i];

                if (event.type === 'layer') {
                    if (activeErosionPoints) {
                        drawLayerAboveErosion(workCtx, surfaceY, event, activeErosionPoints);
                        activeErosionPoints = null;
                    } else {
                        drawLayerWithFolds(workCtx, surfaceY, event);
                    }
                    surfaceY -= event.height;

                } else if (event.type === 'fold') {
                    workCanvas = applyFoldToCanvas(workCanvas, event);
                    workCtx = workCanvas.getContext('2d');
                    foldFunctions.push(event);

                    if (activeErosionPoints) {
                        activeErosionPoints = activeErosionPoints.map(p => ({
                            x: p.x,
                            y: p.y + getFoldDisplacement(p.x, event)
                        }));
                    }

                } else if (event.type === 'tilt') {
                    // ëŒ€ê·œëª¨ ê²½ì‚¬: ìº”ë²„ìŠ¤ ì „ì²´ë¥¼ ê¸°ìš¸ì„
                    workCanvas = applyTiltToCanvas(workCanvas, event);
                    workCtx = workCanvas.getContext('2d');

                } else if (event.type === 'erosion') {
                    const erosionY = surfaceY + event.amount;
                    const erosionPoints = generateErosionSurface(erosionY, event);

                    // 1. ìº”ë²„ìŠ¤ í´ë¦¬í•‘ (ì¹¨ì‹)
                    workCanvas = applyErosionToCanvas(workCanvas, erosionPoints);
                    workCtx = workCanvas.getContext('2d');

                    // 2. ë¶€ì •í•© ì„ ì„ ìº”ë²„ìŠ¤ì— ì¦‰ì‹œ ê·¸ë¦¼ (ì´í›„ ì´ë²¤íŠ¸ê°€ ì´ ìœ„ì— ë®ì–´ì”€)
                    drawUnconformityLine(workCtx, erosionPoints);

                    const minY = Math.min(...erosionPoints.map(p => p.y));
                    activeErosionPoints = erosionPoints;
                    surfaceY = minY;

                } else if (event.type === 'fault') {
                    // ë‹¨ì¸µ: ìº”ë²„ìŠ¤ ì „ì²´ë¥¼ ë³€í˜• (ë¶€ì •í•© ì„  í¬í•¨)
                    workCanvas = applyFaultToCanvas(workCanvas, event, i === selectedIndex);
                    workCtx = workCanvas.getContext('2d');

                    if (activeErosionPoints) {
                        activeErosionPoints = applyFaultToErosionPoints(activeErosionPoints, event);
                    }

                } else if (event.type === 'intrusion') {
                    // ì•”ë§¥ ê´€ì…: ìº”ë²„ìŠ¤ ìœ„ì— ê·¸ë¦¼
                    drawIntrusionToContext(workCtx, event, i === selectedIndex);

                } else if (event.type === 'sill') {
                    // ë³‘ë°˜ ê´€ì…: ë°˜íƒ€ì›í˜•ìœ¼ë¡œ ê·¸ë¦¼
                    drawSillToContext(workCtx, event, i === selectedIndex);

                } else if (event.type === 'batholith') {
                    // ì €ë°˜ ê´€ì…: ë²„ì„¯í˜•ìœ¼ë¡œ ê·¸ë¦¼
                    drawBatholithToContext(workCtx, event, i === selectedIndex);
                }
            }

            // ìµœì¢… ê²°ê³¼ ì¶œë ¥: ê°€ìƒ ìº”ë²„ìŠ¤ì˜ ê°€ì‹œ ì˜ì—­ë§Œ ì¶”ì¶œ
            // drawImage(source, sx, sy, sw, sh, dx, dy, dw, dh)
            ctx.drawImage(workCanvas, OFFSET_X, OFFSET_Y, WIDTH, HEIGHT, 0, 0, WIDTH, HEIGHT);
        }

        function drawBackground(context, w = WIDTH, h = HEIGHT) {
            const bgGradient = context.createLinearGradient(0, 0, 0, h);
            bgGradient.addColorStop(0, '#87CEEB');
            bgGradient.addColorStop(0.15, '#B0C4DE');
            bgGradient.addColorStop(1, '#8B7355');
            context.fillStyle = bgGradient;
            context.fillRect(0, 0, w, h);
        }

        function drawEmptyMessage() {
            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            ctx.font = '18px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('ğŸª¨ [ì§€ì¸µ ì¶”ê°€] ë²„íŠ¼ì„ ëˆŒëŸ¬ ì‹œì‘í•˜ì„¸ìš”!', WIDTH/2, HEIGHT/2);
            ctx.textAlign = 'left';
        }

        // ========================================
        // ì§€ì¸µ ê·¸ë¦¬ê¸°
        // ========================================

        function drawLayerWithFolds(context, baseY, layer) {
            // ì§€ì¸µì€ í•­ìƒ í‰í‰í•˜ê²Œ ê·¸ë¦¼ (ìŠµê³¡ì€ ìº”ë²„ìŠ¤ ë³€í˜•ìœ¼ë¡œë§Œ ì ìš©)
            // ë¬´í•œ í™•ì¥ ì›ì¹™: ê°€ìƒ ìº”ë²„ìŠ¤ ì „ì²´ ë„ˆë¹„ë¡œ ê·¸ë¦¼ (íšŒì „ ì‹œ ì˜ë¦¼ ë°©ì§€)
            context.fillStyle = layer.color;
            context.beginPath();

            // ê°€ìƒ ìº”ë²„ìŠ¤ ì „ì²´ ë„ˆë¹„ë¡œ í‰í‰í•œ ì‚¬ê°í˜• ê·¸ë¦¬ê¸°
            context.moveTo(0, baseY);
            context.lineTo(VIRTUAL_WIDTH, baseY);
            context.lineTo(VIRTUAL_WIDTH, baseY - layer.height);
            context.lineTo(0, baseY - layer.height);

            context.closePath();
            context.fill();

            // ê²½ê³„ì„  (ë” ì§„í•˜ê²Œ)
            context.strokeStyle = 'rgba(0,0,0,0.4)';
            context.lineWidth = 1.5;
            context.beginPath();
            context.moveTo(0, baseY - layer.height);
            context.lineTo(VIRTUAL_WIDTH, baseY - layer.height);
            context.stroke();
        }

        function drawLayerAboveErosion(context, baseY, layer, erosionPoints) {
            // ë¬´í•œ í™•ì¥ ì›ì¹™: ê°€ìƒ ìº”ë²„ìŠ¤ ì „ì²´ ë„ˆë¹„ë¡œ ê·¸ë¦¼
            const segments = 150;
            const segmentWidth = VIRTUAL_WIDTH / segments;

            context.fillStyle = layer.color;
            context.beginPath();

            // ì§€ì¸µì˜ ë°”ë‹¥ë©´: ë¶€ì •í•© íŒŒí˜•ì„ ë”°ë¼ê° (ê°€ìƒ ìº”ë²„ìŠ¤ ì „ì²´)
            context.moveTo(0, getErosionYAtX(erosionPoints, 0));
            for (let i = 1; i <= segments; i++) {
                const x = i * segmentWidth;
                const erosionY = getErosionYAtX(erosionPoints, x);
                context.lineTo(x, erosionY);
            }

            // ì§€ì¸µì˜ ìœ—ë©´: í•­ìƒ í‰í‰í•˜ê²Œ (ê°€ìƒ ìº”ë²„ìŠ¤ ì „ì²´ ë„ˆë¹„)
            const topY = baseY - layer.height;
            context.lineTo(VIRTUAL_WIDTH, topY);
            context.lineTo(0, topY);

            context.closePath();
            context.fill();

            // ìœ—ë©´ ê²½ê³„ì„  (í‰í‰í•œ ì„ )
            context.strokeStyle = 'rgba(0,0,0,0.4)';
            context.lineWidth = 1.5;
            context.beginPath();
            context.moveTo(0, topY);
            context.lineTo(VIRTUAL_WIDTH, topY);
            context.stroke();
        }

        function getFoldDisplacement(x, fold) {
            // ìŠµê³¡ ì¤‘ì‹¬ì€ ê°€ì‹œ ì˜ì—­ ê¸°ì¤€ â†’ ê°€ìƒ ìº”ë²„ìŠ¤ ì¢Œí‘œë¡œ ë³€í™˜
            const centerX = OFFSET_X + fold.position / 100 * WIDTH;
            const distance = x - centerX;
            const wavelength = fold.wavelength;
            const amplitude = fold.amplitude;
            const decay = Math.exp(-(distance * distance) / (wavelength * wavelength * 0.5));
            return amplitude * Math.cos((distance / wavelength) * Math.PI * 2) * decay;
        }

        // ========================================
        // ìŠµê³¡ ì ìš©
        // ========================================

        function applyFoldToCanvas(sourceCanvas, fold) {
            const sw = sourceCanvas.width;
            const sh = sourceCanvas.height;

            const resultCanvas = document.createElement('canvas');
            resultCanvas.width = sw;
            resultCanvas.height = sh;
            const resultCtx = resultCanvas.getContext('2d');

            const sourceCtx = sourceCanvas.getContext('2d');
            const imageData = sourceCtx.getImageData(0, 0, sw, sh);
            const resultImageData = resultCtx.createImageData(sw, sh);

            for (let x = 0; x < sw; x++) {
                const displacement = getFoldDisplacement(x, fold);
                for (let y = 0; y < sh; y++) {
                    const srcY = Math.round(y - displacement);
                    if (srcY >= 0 && srcY < sh) {
                        const srcIdx = (srcY * sw + x) * 4;
                        const dstIdx = (y * sw + x) * 4;
                        resultImageData.data[dstIdx] = imageData.data[srcIdx];
                        resultImageData.data[dstIdx + 1] = imageData.data[srcIdx + 1];
                        resultImageData.data[dstIdx + 2] = imageData.data[srcIdx + 2];
                        resultImageData.data[dstIdx + 3] = imageData.data[srcIdx + 3];
                    }
                }
            }

            resultCtx.putImageData(resultImageData, 0, 0);

            // ë¹ˆ ì˜ì—­(íˆ¬ëª…)ì— ë°°ê²½ ì±„ìš°ê¸°
            resultCtx.globalCompositeOperation = 'destination-over';
            drawBackground(resultCtx, sw, sh);
            resultCtx.globalCompositeOperation = 'source-over';

            return resultCanvas;
        }

        // ëŒ€ê·œëª¨ ê²½ì‚¬(ê¸°ìš¸ê¸°) ì ìš© - ì „ì²´ ìº”ë²„ìŠ¤ë¥¼ ê¸°ìš¸ì„
        function applyTiltToCanvas(sourceCanvas, tilt) {
            const sw = sourceCanvas.width;
            const sh = sourceCanvas.height;

            const resultCanvas = document.createElement('canvas');
            resultCanvas.width = sw;
            resultCanvas.height = sh;
            const resultCtx = resultCanvas.getContext('2d');

            const angleRad = tilt.angle * Math.PI / 180;

            // íšŒì „ ì¤‘ì‹¬ì : ê°€ì‹œ ì˜ì—­ í•˜ë‹¨ ì¤‘ì•™ (ê°€ìƒ ìº”ë²„ìŠ¤ ì¢Œí‘œ)
            const pivotX = OFFSET_X + WIDTH / 2;
            const pivotY = OFFSET_Y + HEIGHT;

            resultCtx.save();
            resultCtx.translate(pivotX, pivotY);
            resultCtx.rotate(angleRad);
            resultCtx.translate(-pivotX, -pivotY);
            resultCtx.drawImage(sourceCanvas, 0, 0);
            resultCtx.restore();

            // ë¹ˆ ì˜ì—­(íˆ¬ëª…)ì— ë°°ê²½ ì±„ìš°ê¸°
            resultCtx.globalCompositeOperation = 'destination-over';
            drawBackground(resultCtx, sw, sh);
            resultCtx.globalCompositeOperation = 'source-over';

            return resultCanvas;
        }

        // ========================================
        // ì¹¨ì‹ ì ìš©
        // ========================================

        function applyErosionToCanvas(sourceCanvas, erosionPoints) {
            const sw = sourceCanvas.width;
            const sh = sourceCanvas.height;

            // í´ë¦¬í•‘ìš© ì„ì‹œ ìº”ë²„ìŠ¤
            const clippedCanvas = document.createElement('canvas');
            clippedCanvas.width = sw;
            clippedCanvas.height = sh;
            const clippedCtx = clippedCanvas.getContext('2d');

            // ì¹¨ì‹ë©´ ì•„ë˜ ì˜ì—­ë§Œ í´ë¦¬í•‘ (ê°€ìƒ ìº”ë²„ìŠ¤ ì „ì²´)
            clippedCtx.beginPath();
            clippedCtx.moveTo(0, sh);
            erosionPoints.forEach(point => {
                clippedCtx.lineTo(point.x, point.y);
            });
            clippedCtx.lineTo(sw, sh);
            clippedCtx.closePath();
            clippedCtx.clip();
            clippedCtx.drawImage(sourceCanvas, 0, 0);

            // í´ë¦¬í•‘ ì—†ëŠ” ê¹¨ë—í•œ ìº”ë²„ìŠ¤ì— ë³µì‚¬ (ì´í›„ ê·¸ë¦¬ê¸° ì‘ì—…ì´ í´ë¦¬í•‘ë˜ì§€ ì•Šë„ë¡)
            const resultCanvas = document.createElement('canvas');
            resultCanvas.width = sw;
            resultCanvas.height = sh;
            const resultCtx = resultCanvas.getContext('2d');
            resultCtx.drawImage(clippedCanvas, 0, 0);

            // ë¹ˆ ì˜ì—­(íˆ¬ëª…)ì— ë°°ê²½ ì±„ìš°ê¸°
            resultCtx.globalCompositeOperation = 'destination-over';
            drawBackground(resultCtx, sw, sh);
            resultCtx.globalCompositeOperation = 'source-over';

            return resultCanvas;
        }

        function applyFaultToErosionPoints(erosionPoints, fault) {
            // ë‹¨ì¸µ ìœ„ì¹˜ëŠ” ê°€ì‹œ ì˜ì—­ ê¸°ì¤€ â†’ ê°€ìƒ ìº”ë²„ìŠ¤ ì¢Œí‘œë¡œ ë³€í™˜
            const faultX = OFFSET_X + fault.position / 100 * WIDTH;
            const angle = fault.angle;
            const hangingOffset = fault.hangingWallOffset || 0;
            const footOffset = fault.footwallOffset || 0;

            // ê°ë„ì— ë”°ë¼ ìƒë°˜/í•˜ë°˜ ê²°ì •
            const isLeftHanging = angle < 90;

            return erosionPoints.map(p => {
                if (p.x < faultX) {
                    const offset = isLeftHanging ? hangingOffset : footOffset;
                    return { x: p.x, y: p.y - offset };
                } else {
                    const offset = isLeftHanging ? footOffset : hangingOffset;
                    return { x: p.x, y: p.y - offset };
                }
            });
        }

        function drawUnconformityLine(context, points) {
            context.save();
            context.strokeStyle = '#FF6600';
            context.lineWidth = 3;

            // ë¶€ì •í•© ì„  ê·¸ë¦¬ê¸° (ê°€ìƒ ìº”ë²„ìŠ¤ ì „ì²´)
            context.beginPath();
            points.forEach((point, i) => {
                if (i === 0) context.moveTo(point.x, point.y);
                else context.lineTo(point.x, point.y);
            });
            context.stroke();

            // ë¼ë²¨ - ê°€ì‹œ ì˜ì—­ ì™¼ìª½ì— í‘œì‹œ
            context.fillStyle = '#FF6600';
            context.font = 'bold 12px sans-serif';
            const labelY = getErosionYAtX(points, OFFSET_X);
            context.fillText('ã€° ë¶€ì •í•©', OFFSET_X + 10, labelY - 10);

            context.restore();
        }

        // ========================================
        // ë‹¨ì¸µ ì ìš© (ìƒë°˜/í•˜ë°˜ ê°œë³„ ì´ë™)
        // ========================================

        /**
         * ë‹¨ì¸µë©´ ê¸°ì¤€ ìƒë°˜/í•˜ë°˜ ê²°ì •:
         * - ê°ë„ < 90Â° (/ ê¸°ìš¸ê¸°): ì™¼ìª½ì´ ìƒë°˜, ì˜¤ë¥¸ìª½ì´ í•˜ë°˜
         * - ê°ë„ > 90Â° (\ ê¸°ìš¸ê¸°): ì˜¤ë¥¸ìª½ì´ ìƒë°˜, ì™¼ìª½ì´ í•˜ë°˜
         * - ê°ë„ = 90Â° (ìˆ˜ì§): ì¢Œìš° ëŒ€ì¹­, ìƒë°˜/í•˜ë°˜ êµ¬ë¶„ ì—†ìŒ
         */
        function applyFaultToCanvas(sourceCanvas, fault, isSelected) {
            const sw = sourceCanvas.width;
            const sh = sourceCanvas.height;

            const resultCanvas = document.createElement('canvas');
            resultCanvas.width = sw;
            resultCanvas.height = sh;
            const resultCtx = resultCanvas.getContext('2d');

            // ë‹¨ì¸µ ìœ„ì¹˜ëŠ” ê°€ì‹œ ì˜ì—­ ê¸°ì¤€ â†’ ê°€ìƒ ìº”ë²„ìŠ¤ ì¢Œí‘œë¡œ ë³€í™˜
            const faultX = OFFSET_X + fault.position / 100 * WIDTH;
            const angleRad = (fault.angle - 90) * Math.PI / 180;
            const hangingOffset = fault.hangingWallOffset || 0;
            const footOffset = fault.footwallOffset || 0;

            // ê°ë„ì— ë”°ë¼ ì–´ëŠ ìª½ì´ ìƒë°˜ì¸ì§€ ê²°ì •
            const isLeftHanging = fault.angle < 90;

            // ì™¼ìª½ ë¸”ë¡ì˜ ì˜¤í”„ì…‹
            const leftOffset = isLeftHanging ? -hangingOffset : -footOffset;
            // ì˜¤ë¥¸ìª½ ë¸”ë¡ì˜ ì˜¤í”„ì…‹
            const rightOffset = isLeftHanging ? -footOffset : -hangingOffset;

            // ìˆ˜ì§ ë‹¨ì¸µ(90ë„)ì¸ ê²½ìš° ì–‘ìª½ ëª¨ë‘ ì ìš©
            const leftOffsetFinal = fault.angle === 90 ? -hangingOffset : leftOffset;
            const rightOffsetFinal = fault.angle === 90 ? -footOffset : rightOffset;

            const extend = sh * 2;
            const dx = Math.sin(angleRad) * extend;
            const dy = Math.cos(angleRad) * extend;

            // ì™¼ìª½ ì˜ì—­
            resultCtx.save();
            resultCtx.beginPath();
            resultCtx.moveTo(0, 0);
            resultCtx.lineTo(faultX - dx, -dy);
            resultCtx.lineTo(faultX + dx, sh + dy);
            resultCtx.lineTo(0, sh);
            resultCtx.closePath();
            resultCtx.clip();
            resultCtx.drawImage(sourceCanvas, 0, leftOffsetFinal);
            resultCtx.restore();

            // ì˜¤ë¥¸ìª½ ì˜ì—­
            resultCtx.save();
            resultCtx.beginPath();
            resultCtx.moveTo(faultX - dx, -dy);
            resultCtx.lineTo(sw, 0);
            resultCtx.lineTo(sw, sh);
            resultCtx.lineTo(faultX + dx, sh + dy);
            resultCtx.closePath();
            resultCtx.clip();
            resultCtx.drawImage(sourceCanvas, 0, rightOffsetFinal);
            resultCtx.restore();

            // ë‹¨ì¸µì„ 
            resultCtx.save();
            resultCtx.strokeStyle = isSelected ? '#FF0000' : '#CC0000';
            resultCtx.lineWidth = isSelected ? 4 : 2;
            resultCtx.setLineDash([8, 4]);
            resultCtx.beginPath();
            resultCtx.moveTo(faultX - dx, -dy);
            resultCtx.lineTo(faultX + dx, sh + dy);
            resultCtx.stroke();
            resultCtx.setLineDash([]);
            resultCtx.restore();

            // ìƒë°˜/í•˜ë°˜ ë¼ë²¨ í‘œì‹œ (ì„ íƒëœ ê²½ìš°) - ê°€ì‹œ ì˜ì—­ ì¤‘ì•™ì— í‘œì‹œ
            if (isSelected) {
                resultCtx.save();
                resultCtx.font = 'bold 12px sans-serif';
                resultCtx.fillStyle = '#FFD700';
                const labelY = OFFSET_Y + HEIGHT / 2;

                if (fault.angle < 90) {
                    resultCtx.fillText('ìƒë°˜', faultX - 50, labelY);
                    resultCtx.fillText('í•˜ë°˜', faultX + 20, labelY);
                } else if (fault.angle > 90) {
                    resultCtx.fillText('í•˜ë°˜', faultX - 50, labelY);
                    resultCtx.fillText('ìƒë°˜', faultX + 20, labelY);
                }
                resultCtx.restore();
            }

            // ë¹ˆ ì˜ì—­(íˆ¬ëª…)ì— ë°°ê²½ ì±„ìš°ê¸°
            resultCtx.globalCompositeOperation = 'destination-over';
            drawBackground(resultCtx, sw, sh);
            resultCtx.globalCompositeOperation = 'source-over';

            return resultCanvas;
        }

        // ========================================
        // ê´€ì… ê·¸ë¦¬ê¸°
        // ========================================

        function drawIntrusionToContext(context, intrusion, isSelected) {
            // ê´€ì… ìœ„ì¹˜ëŠ” ê°€ì‹œ ì˜ì—­ ê¸°ì¤€ â†’ ê°€ìƒ ìº”ë²„ìŠ¤ ì¢Œí‘œë¡œ ë³€í™˜
            const posX = OFFSET_X + intrusion.position / 100 * WIDTH;
            const angleRad = (intrusion.angle - 90) * Math.PI / 180;
            const intrusionWidth = intrusion.width;
            const intrusionLength = VIRTUAL_HEIGHT * 1.2;  // ê°€ìƒ ìº”ë²„ìŠ¤ ë†’ì´ ê¸°ì¤€
            const metaThickness = intrusion.metaThickness || 0;

            context.save();
            context.translate(posX, OFFSET_Y + HEIGHT / 2);
            context.rotate(angleRad);

            if (metaThickness > 0) {
                const totalWidth = intrusionWidth + metaThickness * 2;

                const metaGradient = context.createLinearGradient(-totalWidth/2, 0, totalWidth/2, 0);
                metaGradient.addColorStop(0, 'rgba(255, 200, 100, 0)');
                metaGradient.addColorStop(0.15, 'rgba(255, 180, 50, 0.7)');
                metaGradient.addColorStop(0.25, 'rgba(200, 150, 50, 0.9)');
                metaGradient.addColorStop(0.35, 'rgba(150, 100, 50, 0.6)');
                metaGradient.addColorStop(0.5, 'rgba(150, 100, 50, 0)');
                metaGradient.addColorStop(0.65, 'rgba(150, 100, 50, 0.6)');
                metaGradient.addColorStop(0.75, 'rgba(200, 150, 50, 0.9)');
                metaGradient.addColorStop(0.85, 'rgba(255, 180, 50, 0.7)');
                metaGradient.addColorStop(1, 'rgba(255, 200, 100, 0)');

                context.fillStyle = metaGradient;
                context.fillRect(-totalWidth/2, -intrusionLength/2, totalWidth, intrusionLength);
            }

            const gradient = context.createLinearGradient(-intrusionWidth/2, 0, intrusionWidth/2, 0);
            gradient.addColorStop(0, '#5B0000');
            gradient.addColorStop(0.2, '#7B0000');
            gradient.addColorStop(0.5, '#9B2020');
            gradient.addColorStop(0.8, '#7B0000');
            gradient.addColorStop(1, '#5B0000');

            context.fillStyle = gradient;
            context.fillRect(-intrusionWidth/2, -intrusionLength/2, intrusionWidth, intrusionLength);

            context.strokeStyle = isSelected ? '#FFD700' : '#3D0000';
            context.lineWidth = isSelected ? 3 : 2;
            context.strokeRect(-intrusionWidth/2, -intrusionLength/2, intrusionWidth, intrusionLength);

            context.fillStyle = 'rgba(255,255,255,0.12)';
            for (let i = 0; i < 30; i++) {
                const x = (Math.random() - 0.5) * intrusionWidth * 0.8;
                const y = (Math.random() - 0.5) * intrusionLength * 0.95;
                const size = Math.random() * 2 + 1;
                context.beginPath();
                context.arc(x, y, size, 0, Math.PI * 2);
                context.fill();
            }

            context.restore();
        }

        // ë³‘ë°˜(ë°˜íƒ€ì›í˜•) ê´€ì… ê·¸ë¦¬ê¸°
        function drawSillToContext(context, sill, isSelected) {
            // ë³‘ë°˜ ìœ„ì¹˜ëŠ” ê°€ì‹œ ì˜ì—­ ê¸°ì¤€ â†’ ê°€ìƒ ìº”ë²„ìŠ¤ ì¢Œí‘œë¡œ ë³€í™˜
            const posX = OFFSET_X + sill.position / 100 * WIDTH;
            const posY = OFFSET_Y + sill.depth / 50 * HEIGHT;  // 50% = ê°€ì‹œ ì˜ì—­ ë°”ë‹¥
            const sillWidth = sill.width;
            const sillHeight = sill.height;
            const metaThickness = sill.metaThickness || 0;
            const angleRad = (sill.angle || 0) * Math.PI / 180;  // ê°ë„ë¥¼ ë¼ë””ì•ˆìœ¼ë¡œ

            // ë¬´í•œ ìº”ë²„ìŠ¤ ì›ì¹™: ì•„ë˜ìª½ í™•ì¥ ë†’ì´ ê³„ì‚°
            const extensionHeight = VIRTUAL_HEIGHT - posY + 100;  // ì—¬ìœ ìˆê²Œ í™•ì¥

            context.save();

            // ìœ„ì¹˜ë¡œ ì´ë™ í›„ íšŒì „
            context.translate(posX, posY);
            context.rotate(angleRad);

            // ë¬´í•œ ìº”ë²„ìŠ¤ ì›ì¹™: ì•„ë˜ìª½ í™•ì¥ (ê¸°ìš¸ê¸° ì ìš© ì‹œ ë¹ˆ ê³µê°„ ë°©ì§€)
            // ì ‘ì´‰ ë³€ì„±ëŒ€ ì•„ë˜ìª½ í™•ì¥
            if (metaThickness > 0) {
                context.fillStyle = 'rgba(255, 180, 50, 0.4)';
                context.fillRect(-sillWidth/2 - metaThickness, 0, sillWidth + metaThickness * 2, extensionHeight);
            }

            // ë³‘ë°˜ ë³¸ì²´ ì•„ë˜ìª½ í™•ì¥
            context.fillStyle = '#5B0000';
            context.fillRect(-sillWidth/2, 0, sillWidth, extensionHeight);

            // ì ‘ì´‰ ë³€ì„±ëŒ€ (ë°˜íƒ€ì› ì£¼ë³€) - ì›ì  ê¸°ì¤€ìœ¼ë¡œ ê·¸ë¦¬ê¸°
            if (metaThickness > 0) {
                const metaGradient = context.createRadialGradient(
                    0, 0, 0,
                    0, 0, Math.max(sillWidth/2, sillHeight) + metaThickness
                );
                metaGradient.addColorStop(0, 'rgba(255, 180, 50, 0)');
                metaGradient.addColorStop(0.5, 'rgba(255, 180, 50, 0.5)');
                metaGradient.addColorStop(0.7, 'rgba(200, 150, 50, 0.7)');
                metaGradient.addColorStop(1, 'rgba(200, 150, 50, 0)');

                context.fillStyle = metaGradient;
                context.beginPath();
                context.ellipse(0, 0, sillWidth/2 + metaThickness, sillHeight + metaThickness, 0, Math.PI, 0);
                context.fill();
            }

            // ë³‘ë°˜ ë³¸ì²´ (ë°˜íƒ€ì› - ìœ„ìª½ ë³¼ë¡) - ì›ì  ê¸°ì¤€
            const gradient = context.createLinearGradient(0, -sillHeight, 0, 0);
            gradient.addColorStop(0, '#9B2020');
            gradient.addColorStop(0.3, '#7B0000');
            gradient.addColorStop(0.7, '#5B0000');
            gradient.addColorStop(1, '#4B0000');

            context.fillStyle = gradient;
            context.beginPath();
            context.ellipse(0, 0, sillWidth/2, sillHeight, 0, Math.PI, 0);
            context.fill();

            // í…Œë‘ë¦¬
            context.strokeStyle = isSelected ? '#FFD700' : '#3D0000';
            context.lineWidth = isSelected ? 3 : 2;
            context.beginPath();
            context.ellipse(0, 0, sillWidth/2, sillHeight, 0, Math.PI, 0);
            context.stroke();

            // í…ìŠ¤ì²˜ (ê²°ì • íŒ¨í„´) - ì›ì  ê¸°ì¤€
            context.fillStyle = 'rgba(255,255,255,0.1)';
            for (let i = 0; i < 25; i++) {
                const angle = Math.random() * Math.PI;
                const r = Math.random();
                const x = Math.cos(angle) * (sillWidth/2 * 0.85) * r;
                const y = -Math.sin(angle) * (sillHeight * 0.85) * r;
                const size = Math.random() * 2 + 1;
                context.beginPath();
                context.arc(x, y, size, 0, Math.PI * 2);
                context.fill();
            }

            context.restore();
        }

        // ì €ë°˜(ë²„ì„¯í˜•) ê´€ì… ê·¸ë¦¬ê¸°
        function drawBatholithToContext(context, batholith, isSelected) {
            // ì €ë°˜ ìœ„ì¹˜ëŠ” ê°€ì‹œ ì˜ì—­ ê¸°ì¤€ â†’ ê°€ìƒ ìº”ë²„ìŠ¤ ì¢Œí‘œë¡œ ë³€í™˜
            const posX = OFFSET_X + batholith.position / 100 * WIDTH;
            const stemWidth = batholith.stemWidth;
            const headWidth = batholith.headWidth;
            const headHeight = batholith.headHeight;
            // headPosYë„ ê°€ì‹œ ì˜ì—­ ê¸°ì¤€ â†’ ê°€ìƒ ìº”ë²„ìŠ¤ ì¢Œí‘œë¡œ ë³€í™˜
            const headPosY = OFFSET_Y + (batholith.headPosY || headHeight);
            const metaThickness = batholith.metaThickness || 0;
            const bottomY = VIRTUAL_HEIGHT;  // ë¬´í•œ ìº”ë²„ìŠ¤ ì›ì¹™: ê°€ìƒ ìº”ë²„ìŠ¤ í•˜ë‹¨ê¹Œì§€ í™•ì¥
            const stemAngle = batholith.stemAngle || 0;  // ì¤„ê¸° ê¸°ìš¸ê¸°

            // ì¤„ê¸° ê¸°ìš¸ê¸°ì— ë”°ë¥¸ ë°”ë‹¥ X ì˜¤í”„ì…‹ ê³„ì‚°
            const stemHeight = bottomY - headPosY;
            const stemAngleRad = stemAngle * Math.PI / 180;
            const bottomXOffset = Math.tan(stemAngleRad) * stemHeight;

            context.save();

            // ì ‘ì´‰ ë³€ì„±ëŒ€ ê·¸ë¦¬ê¸° (ì¤„ê¸°ì™€ ë¨¸ë¦¬ ë¶„ë¦¬ - ìˆ˜í‰ ì—°ê²°ì„  ì œê±°)
            if (metaThickness > 0) {
                context.fillStyle = 'rgba(255, 180, 50, 0.4)';

                // 1. ì¤„ê¸° ë³€ì„±ëŒ€ (ê¸°ìš¸ê¸° ë°˜ì˜ + ë¨¸ë¦¬ body ë’¤ìª½ê¹Œì§€ ì—°ì¥)
                context.beginPath();
                // ë°”ë‹¥ ì™¼ìª½
                context.moveTo(posX - stemWidth/2 - metaThickness + bottomXOffset, bottomY);
                // headPosY ì™¼ìª½ (ê¸°ìš¸ê¸° ì ìš©)
                context.lineTo(posX - stemWidth/2 - metaThickness, headPosY);
                // ë¨¸ë¦¬ ì˜ì—­ìœ¼ë¡œ ìˆ˜ì§ ì—°ì¥ (ë‚˜ì¤‘ì— ë¨¸ë¦¬ bodyê°€ ë®ìŒ)
                context.lineTo(posX - stemWidth/2 - metaThickness, headPosY - headHeight);
                // ì˜¤ë¥¸ìª½ ìƒë‹¨
                context.lineTo(posX + stemWidth/2 + metaThickness, headPosY - headHeight);
                // headPosY ì˜¤ë¥¸ìª½ (ê¸°ìš¸ê¸° ì ìš©)
                context.lineTo(posX + stemWidth/2 + metaThickness, headPosY);
                // ë°”ë‹¥ ì˜¤ë¥¸ìª½
                context.lineTo(posX + stemWidth/2 + metaThickness + bottomXOffset, bottomY);
                context.closePath();
                context.fill();

                // 2. ë¨¸ë¦¬ ë³€ì„±ëŒ€ (ë°˜íƒ€ì› - ê²¹ì¹˜ëŠ” ë¶€ë¶„ì€ ë¨¸ë¦¬ bodyê°€ ë®ì–´ì„œ ì•ˆ ë³´ì„)
                context.beginPath();
                context.ellipse(posX, headPosY, headWidth/2 + metaThickness, headHeight + metaThickness, 0, Math.PI, 0);
                context.fill();
            }

            // ì €ë°˜ ë³¸ì²´ (ì¤„ê¸° + ë¨¸ë¦¬ë¥¼ í•˜ë‚˜ì˜ ì—°ì†ëœ ê²½ë¡œë¡œ ê·¸ë ¤ì„œ ê²½ê³„ ì—†ì•°)
            const bodyGradient = context.createLinearGradient(posX, headPosY - headHeight, posX, bottomY);
            bodyGradient.addColorStop(0, '#9B2020');
            bodyGradient.addColorStop(0.15, '#7B0000');
            bodyGradient.addColorStop(0.4, '#5B0000');
            bodyGradient.addColorStop(1, '#4B0000');

            context.fillStyle = bodyGradient;
            context.beginPath();
            // ì¤„ê¸° ì™¼ìª½ í•˜ë‹¨ì—ì„œ ì‹œì‘
            context.moveTo(posX - stemWidth/2 + bottomXOffset, bottomY);
            // ì¤„ê¸° ì™¼ìª½ ìƒë‹¨
            context.lineTo(posX - stemWidth/2, headPosY);
            // ë¨¸ë¦¬ ì™¼ìª½ ëìœ¼ë¡œ (ì¤„ê¸°ì™€ ë¨¸ë¦¬ ì—°ê²°)
            context.lineTo(posX - headWidth/2, headPosY);
            // ë¨¸ë¦¬ ìœ„ìª½ ë°˜íƒ€ì›
            context.ellipse(posX, headPosY, headWidth/2, headHeight, 0, Math.PI, 0);
            // ë¨¸ë¦¬ ì˜¤ë¥¸ìª½ ëì—ì„œ ì¤„ê¸° ì˜¤ë¥¸ìª½ ìƒë‹¨ìœ¼ë¡œ
            context.lineTo(posX + stemWidth/2, headPosY);
            // ì¤„ê¸° ì˜¤ë¥¸ìª½ í•˜ë‹¨
            context.lineTo(posX + stemWidth/2 + bottomXOffset, bottomY);
            context.closePath();
            context.fill();

            // í…Œë‘ë¦¬ (ì „ì²´ ì™¸ê³½ì„ )
            context.strokeStyle = isSelected ? '#FFD700' : '#3D0000';
            context.lineWidth = isSelected ? 3 : 2;
            context.beginPath();
            // ì¤„ê¸° ì™¼ìª½
            context.moveTo(posX - stemWidth/2 + bottomXOffset, bottomY);
            context.lineTo(posX - stemWidth/2, headPosY);
            // ë¨¸ë¦¬ ì™¼ìª½ í•˜ë‹¨ìœ¼ë¡œ
            context.lineTo(posX - headWidth/2, headPosY);
            // ë¨¸ë¦¬ ìœ„ìª½ ë°˜íƒ€ì›
            context.ellipse(posX, headPosY, headWidth/2, headHeight, 0, Math.PI, 0);
            // ë¨¸ë¦¬ ì˜¤ë¥¸ìª½ì—ì„œ ì¤„ê¸° ì˜¤ë¥¸ìª½ìœ¼ë¡œ
            context.lineTo(posX + stemWidth/2, headPosY);
            // ì¤„ê¸° ì˜¤ë¥¸ìª½ í•˜ë‹¨
            context.lineTo(posX + stemWidth/2 + bottomXOffset, bottomY);
            context.stroke();

            // í…ìŠ¤ì²˜ (ê²°ì • íŒ¨í„´)
            context.fillStyle = 'rgba(255,255,255,0.1)';
            // ì¤„ê¸° í…ìŠ¤ì²˜ (ê¸°ìš¸ê¸° ë°˜ì˜)
            for (let i = 0; i < 20; i++) {
                const t = Math.random();  // 0~1: ë¨¸ë¦¬ì—ì„œ ë°”ë‹¥ê¹Œì§€ì˜ ë¹„ìœ¨
                const xOffset = bottomXOffset * t;  // ê¸°ìš¸ê¸°ì— ë”°ë¥¸ X ì˜¤í”„ì…‹
                const x = posX + (Math.random() - 0.5) * stemWidth * 0.8 + xOffset;
                const y = headPosY + t * (bottomY - headPosY) * 0.9;
                const size = Math.random() * 2 + 1;
                context.beginPath();
                context.arc(x, y, size, 0, Math.PI * 2);
                context.fill();
            }
            // ë¨¸ë¦¬ í…ìŠ¤ì²˜
            for (let i = 0; i < 30; i++) {
                const angle = Math.random() * Math.PI;
                const r = Math.random();
                const x = posX + Math.cos(angle) * (headWidth/2 * 0.85) * r;
                const y = headPosY - Math.sin(angle) * (headHeight * 0.85) * r;
                const size = Math.random() * 2 + 1;
                context.beginPath();
                context.arc(x, y, size, 0, Math.PI * 2);
                context.fill();
            }

            context.restore();
        }

        // ========================================
        // ì „ì²´ í™”ë©´ ê¸°ëŠ¥
        // ========================================
        function toggleFullscreen() {
            const wrapper = document.getElementById('canvasWrapper');

            if (!document.fullscreenElement && !document.webkitFullscreenElement) {
                if (wrapper.requestFullscreen) {
                    wrapper.requestFullscreen();
                } else if (wrapper.webkitRequestFullscreen) {
                    wrapper.webkitRequestFullscreen();
                }
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                }
            }
        }

        // ESC í‚¤ë¡œ ì „ì²´ í™”ë©´ ì¢…ë£Œ ì‹œ ë²„íŠ¼ í…ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸
        document.addEventListener('fullscreenchange', updateFullscreenButton);
        document.addEventListener('webkitfullscreenchange', updateFullscreenButton);

        function updateFullscreenButton() {
            const btn = document.querySelector('.fullscreen-btn');
            if (document.fullscreenElement || document.webkitFullscreenElement) {
                btn.textContent = 'â›¶ ì „ì²´ í™”ë©´ ì¢…ë£Œ';
            } else {
                btn.textContent = 'â›¶ ì „ì²´ í™”ë©´';
            }
        }

        // ========================================
        // ì´ˆê¸°í™”
        // ========================================
        render();
        updateTimeline();
    </script>
</body>
</html>
